// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AutoRebaseToken {
    string public name = "AutoRebaseToken";
    string public symbol = "ART";
    uint8 public decimals = 18;

    address public owner;
    uint256 public baseTotalSupply = 100_000_000 * 10**18; // Suministro inicial
    uint256 public rebaseRate = 105; // +5% cada 7 dÃ­as
    uint256 public rebaseInterval = 7 days;
    uint256 public lastRebase;

    uint256 public monthlyDropAmount = 10 * 10**18;
    uint256 public monthlyDropInterval = 30 days;
    uint256 public lastMonthlyDrop;

    mapping(address => uint256) internal baseBalances;
    mapping(address => bool) internal initialized;
    mapping(address => uint256) public lastTransfer;

    address[] internal holders;

    modifier onlyOwner() {
        require(msg.sender == owner, "No autorizado");
        _;
    }

    constructor() {
        owner = msg.sender;
        baseBalances[owner] = baseTotalSupply;
        holders.push(owner);
        initialized[owner] = true;
        lastRebase = block.timestamp;
        lastMonthlyDrop = block.timestamp;
        lastTransfer[owner] = block.timestamp;
    }

    function balanceOf(address account) public view returns (uint256) {
        return applyRebase(baseBalances[account]);
    }

    function applyRebase(uint256 baseAmount) internal view returns (uint256) {
        uint256 cycles = (block.timestamp - lastRebase) / rebaseInterval;
        for (uint256 i = 0; i < cycles; i++) {
            baseAmount = (baseAmount * rebaseRate) / 100;
        }
        return baseAmount;
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        rebase();
        monthlyDrop();

        uint256 baseAmount = (amount * 100) / rebaseRate;
        require(baseBalances[msg.sender] >= baseAmount, "Saldo insuficiente");

        baseBalances[msg.sender] -= baseAmount;

        if (!initialized[to]) {
            holders.push(to);
            initialized[to] = true;
        }

        baseBalances[to] += baseAmount;

        // Registrar actividad
        lastTransfer[msg.sender] = block.timestamp;
        lastTransfer[to] = block.timestamp;

        return true;
    }

    function rebase() public {
        uint256 cycles = (block.timestamp - lastRebase) / rebaseInterval;
        if (cycles == 0) return;

        for (uint256 i = 0; i < holders.length; i++) {
            for (uint256 j = 0; j < cycles; j++) {
                baseBalances[holders[i]] = (baseBalances[holders[i]] * rebaseRate) / 100;
            }
        }

        lastRebase += cycles * rebaseInterval;
    }

    function monthlyDrop() public {
        if (block.timestamp < lastMonthlyDrop + monthlyDropInterval) return;

        for (uint256 i = 0; i < holders.length; i++) {
            address user = holders[i];
            if (lastTransfer[user] >= block.timestamp - monthlyDropInterval) {
                baseBalances[user] += monthlyDropAmount;
                baseTotalSupply += monthlyDropAmount;
            }
        }

        lastMonthlyDrop = block.timestamp;
    }

    function mint(address to, uint256 amount) public onlyOwner {
        if (!initialized[to]) {
            holders.push(to);
            initialized[to] = true;
        }

        baseBalances[to] += amount;
        baseTotalSupply += amount;
    }

    function totalSupply() public view returns (uint256) {
        uint256 total;
        for (uint256 i = 0; i < holders.length; i++) {
            total += balanceOf(holders[i]);
        }
        return total;
    }
}
